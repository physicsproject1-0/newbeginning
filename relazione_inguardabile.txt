Relazione progetto di programmazione per la fisica 20/21: simulazione di una pandemia 
Autori: Simone Piraccini, Simone Garnero, Edoardo Frulla 

Parte I: modello SIR

Il modello che rappresenta lo sviluppo della nostra pandemia è il modello SIR, dove S sta per suscettibili, I sta per infetti ed R sta per rimossi (morti o guariti).
Si basa su tre equazioni differenziali caratterizzate da due parametri β e γ che indicano rispettivamente la velocità del contagio e 
quella della fine dell’infezione; tutte le persone della stessa categoria sono indistinguibili.
Ad ogni nuovo giorno la situazione si aggiorna secondo l’algoritmo che segue le equazioni sopra citate, insieme ai dati della giornata precedente.

Abbiamo creato una struct ‘State’ che contenesse i valori caratterizzanti un determinato istante della simulazione, ovvero il giorno 
corrente ed i rispettivi valori di S, I, R. 
La classe ‘SIR’ invece contiene i dati necessari al funzionamento del modello, ovvero uno State 'stato iniziale', i parametri 'beta' e 'gamma', insieme alla durata della simulazione.
Tiene conto anche del valore (costante per tutta la durata della simulazione) dato dal totale delle persone presenti.
‘Insert()’ è la funzione che gestisce l’input e ritorna un oggetto della classe SIR: vengono richiesti quindi all’utente i valori dei parametri beta e gamma 
(decimali tra 0 e 1), il numero di persone suscettibili, infette e rimosse (interi positivi); infine è necessario inserire la durata della simulazione in giorni (intero positivo).

Le funzioni membro ‘riempimento’ e ‘convertitore’ sono chiamate per compiere la vera e propria simulazione dal punto di vista
quantitativo: entrambe ritornano uno std::vector di ‘State’, il primo con dati grezzi, il secondo riporta approssimati all’unità i valori di S, I, R. 
Grazie ad un ciclo for, ‘riempimento’ inserisce i dati nell’algoritmo per generare la giornata successiva e con pushback() riempie il vettore.
Sempre con un ciclo for, ‘convertitore’ (che ha come oggetto il vettore appena creato) approssima all’unità il numero di S, I, R  
in modo da rispettare i seguenti criteri: 
- il numero di suscettibili non può aumentare rispetto alla giornata precedente
- il numero di rimossi non può diminuire rispetto alla giornata precedente
- se il numero di infetti è zero la situazione si stabilizza e i valori si mantengono inalterati il giorno seguente
- quando tali condizioni sono soddisfatte, il sistema approssima per eccesso i valori con decimale più alto in modo da mantenere S+I+R=N

Per verificare il corretto funzionamento di queste funzioni abbiamo scritto un file di test (doctest) per situazioni particolari facilmente
intuibili a priori. 
L'output è rappresentato dalla storia della simulazione, stampata su standard output, e da un grafico gnuplot che riporta le curve di andamento della popolazione.
Per visualizzare il grafico è necessario gnuplot installato abbinato ad un xserver per l'apertura della finestra grafica.
Per la compilazione è possibile utilizzare CMake, oppure il comando "g++ main.cpp newSIR.cpp plot.cpp". Per verificare i test basta sostituire il file di test
al posto del main.
E' possibile ottenere output in formati diversi (implementati attraverso la libreria "Lyra"). Per scegliere formato bisogna bisogna aggiungere durante la compilazione
"-f <opzione>" oppure "--formato <opzione>". I formati disponibili e le parole chiave da inserire in sede di compilazione sono:
- "grafico"  , per ottenere in output solo grafico
- "virgola" , per ottenere i valori separati da virgola
- "spazio" , per ottenere i valori separati da spazio
Nel caso in cui non venga inserita nessuna opzione l'output conterrà sial il grafico che una tabella per i valori.
Compilando con -Wall -Wextra appaiono dei warnings dovuti all'utilizzo della libreria "lyra" (già comunicato).





Parte II: Simulazione grafica

Per la seconda parte del progetto abbiamo deciso di realizzare due simulazioni grafiche stilizzate di una pandemia. Entrambe si trovano sulla stessa 
finestra grafica in cui è presente una Graphic User Interface che permette di passare da una all'altra e di mettere in pausa l'animazione.
In alto a destra è poi disponibile un piccolo grafico che dà un'idea dell'andamento totale della popolazione e un'interfaccia che permette di 
vedere in tempo reale i numeri di persone in ogni stato (Suscettibile, infetto, guarito, morto). 
Per compilare è possibilizzare utilizzare CMake oppure i comandi 
"g++ -c main.cpp mondo.cpp gui.cpp finestra.cpp bordi.cpp pennello.cpp riquadro_informazioni.cpp animazione.cpp automa.cpp", 
"g++ main.o mondo.o gui.o finestra.o bordi.o pennello.o riquadro_informazioni.o animazione.o automa.o -lsfml-graphics -lsfml-window -lsfml-system". Compilando con i comandi -Wall -Wextra -fsanitize=address
, alla chiusura della finestra grafica rimane un memory leak di 56 bytes (già comunicato). 
Il programma richiede l'inserimento in imput dei seguenti valori:

Automa cellulare
- numero celle per lato [intero fra 1 e 10]
- parametro beta (probabilità di contagio) [decimale tra 0 e 1]
- parametro gamma (probabilità di guarigione) [decimale tra 0 e 1]
- parametro eta (probabilità di morte) [decimale tra 0 e 1] 
- celle infette [intero positivo]
- celle rimosse (guarite) [intero positivo]

La somma di gamma ed eta deve essere minore di 1
La somma di celle infette e celle rimosse deve essere minore del totale

Animazione 
- numero di persone totale [intero positivo]
- parametro beta (probabilità di contagio) [decimale tra 0 e 1]
- parametro gamma (probabilità di guarigione) [decimale tra 0 e 1]
- numero persone infette [intero positivo]
- numero persone rimosse (guarite) [intero positivo]

La somma di persone infette e persone rimosse deve essere minore del totale


Simulazione I

La prima consiste in un campione di persone che si muovono all'interno di un territorio delimitato. In questo caso abbiamo deciso 
di distinguere soggetti suscettibili, infetti, guariti e morti. Lo stato dei soggetti si
distingue grazie al loro colore: verde per i suscettibili, rosso per gli infetti, grigio per i morti e azzurro per i guariti.
Gli infetti vengono distribuiti randomicamente all'interno della regione. Ogni persona si muove con una velocità casuale e nel momento in cui un infetto
entra in contatto con un suscettibile ha una certa probabilità di infettarlo. Dopo che un soggetto infetto è entrato in contatto con un elevato numero di 
persone (influenzato dal parametro gamma) diventa morto o guarito. La percentuale di morte è 30%, quella di guarigione 70%.

Abbiamo costituito una classe "Animazione" che contiene tutto l'ambiente. Abbiamo creato una struct "Persona" che rappresenta ogni singolo omino sull'interfaccia grafico. 
Una enum class "Stato" assegna a ogni persona uno dei 4 stati (Suscettibile, Infetto, Morto, Guarito).
All'interno della classe Animazione abbiamo un vertexArray che ospita tutte le coordinate delle persone, i vertici consecutivi (unica persona) sono raggruppati a formare triangoli. 
Ogni persona è definita quindi sulla finestra da 3 coordinate.
Tutte le persone sono raggruppate in una std::map, membro della classe Animazione. I diversi colori delle persone sono dati da diverse texture, tutte
nello stesso file "uomini.png". Per assegnare ai membri con lo stesso stato il medesimo colore, una funzione (SetAllTextures) ritaglia il png ed incolla la texture
La regione delimitata dal rettangolo viene riempita uniformemente all'interno del costruttore attraverso un 'for loop' che cicla per il numero totale 
di persone inserito in input dall'utente. Il numero di infetti iniziale viene qui gestito da un altro ciclo 'for'.
La funzione membro Collisione() gestisce l'infettività, mentre Conteggio_contatti() e Morte_persona() controllano l'uscita dall'infezione.
I movimenti delle persone sono permessi dalle funzioni Aggiorna_lista(), Aggiorna_griglia() e Check_borders(). Attraverso la funzione Aggiorna_Generale()
si passa da un istante all'altro.



Simulazione II 

La seconda simulazione consiste in un automa cellulare costituito da una griglia 'n x n'. Gli stati e i colori delle celle sono gli stessi della 
simulazione 1 (stessa enum Class "Stato"). La situazione della griglia avanza autonomamente ad intervalli discreti. Le celle suscettibili se 
circondate da almeno una cella infetta, hanno una certa probabilita' di infettarsi (parametro 'beta'). Ogni giorno la cella infetta va incontro a 3 opzioni: 
guarire, morire (influenzate rispettivamente dai parametri 'gamma' ed 'eta' forniti dall'utente), oppure restare infetta; le celle guarite e morte sono paragonabili a celle vuote. 
Al contrario della prima simulazione, in questo caso e' possibile intervenire sullo stato delle celle direttamente sulla finestra grafica grazie alla GUI.

L'ambiente completo e' un oggetto della classe Automa. Le singole celle sono invece rappresentate dalla classe Cellula, ereditata dalla classe Bordi.
La funzione Aggiorna_colore() assegna a ogni stato il rispettivo colore. Genera() si occupa di posizionare in maniera casuale le celle infette
e suscettibili richieste all'interno della griglia. Attraverso la funzione Aggiorna() le celle cambiano stato in base alle regole previste e   
con Avanza() ogni 3 secondi la griglia immette le modifiche.
La funzione Aggiorna_senza_avanzare() permette di gestire il cambiamento degli stati delle cellette quando la simulazione è in pausa.


Header Files - breve descrizione degli header scritti per l'intera parte II

Oltre ai due file con i rispettivi header 'animazione.cpp' e 'automa.cpp' già descritti, nella parte grafica ne sono presenti anche altri.

- struct_enum.hpp : contiene classi e funzioni che vengono sfruttate da entrambe le simulazioni quali Casuale(), la funzione template Censimento(),
 la enum class Stato e altre classi/struct

- riquadro_informazioni.hpp : contiene le classi che si occupano del riquadro in alto a destra della finestra grafica con valori per ogni stato 
 e grafico mostrante lo storico della simulazione

- gui.hpp : ospita la classe GUI dell'interfaccia utente

- bordi.hpp : ospita la classe bordi e altre classi per l'implementazione dell'interfaccia grafica come Pulsante e CheckBox

- finestra.hpp : contiene la classe finestra che rappresenta la vera e propria finestra grafica, con le funzioni create e destroy (distruttore)

- mondo.hpp : contiene la classe Mondo che ha come membri un oggetto della classe Finestra, uno di Automa, uno di Animazione e uno di GUI. 
 Nel rispettivo codice sorgente è presente la funzione Inserimento() responsabile dell' Input/Output.
 La funzione Aggiorna() permette di avanzare solamente nella simulazione che si sta guardando.

- pennello.hpp : contiene la classe che permette di cambiare gli stati delle cellette sulla griglia. 

